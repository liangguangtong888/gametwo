<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Adventure - Puzzle Game | GameHaven</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f7;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        #game-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        #game-canvas {
            background-color: #fff;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            max-width: 100%;
            max-height: 100%;
        }
        
        .game-ui {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px 15px;
            border-radius: 30px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(5px);
            display: flex;
            gap: 15px;
            align-items: center;
            z-index: 10;
            font-size: 14px;
        }
        
        .game-ui-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .icon {
            width: 20px;
            height: 20px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        
        .game-controls {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            z-index: 10;
        }
        
        .game-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #0d6efd 0%, #0a58ca 100%);
            color: white;
            border: none;
            border-radius: 30px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(13, 110, 253, 0.25);
        }
        
        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(13, 110, 253, 0.35);
        }
        
        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            color: white;
            display: none;
        }
        
        .game-over h2 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
        }
        
        .game-over p {
            font-size: 24px;
            margin-bottom: 30px;
        }
        
        .game-over-btn {
            padding: 12px 30px;
            background: linear-gradient(135deg, #0d6efd 0%, #0a58ca 100%);
            color: white;
            border: none;
            border-radius: 30px;
            font-size: 18px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }
        
        .game-over-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(255, 255, 255, 0.2);
        }
        
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #f5f5f7;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
        }
        
        .loader {
            width: 250px;
            height: 6px;
            background-color: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        .progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #0d6efd, #0dcaf0);
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        
        .loading-text {
            font-size: 16px;
            color: #6c757d;
        }
    </style>
</head>
<body>
    <!-- åŠ è½½å±å¹• -->
    <div class="loading-screen" id="loading-screen">
        <h2 style="margin-bottom: 30px; color: #0d6efd; font-size: 32px;">Maze Adventure</h2>
        <div class="loader">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
        <div class="loading-text" id="loading-text">0%</div>
    </div>
    
    <!-- æ¸¸æˆå®¹å™¨ -->
    <div id="game-container">
        <canvas id="game-canvas" width="800" height="600"></canvas>
    </div>
    
    <!-- æ¸¸æˆUI -->
    <div class="game-ui">
        <div class="game-ui-item">
            <div class="icon">â±ï¸</div>
            <span id="time">00:00</span>
        </div>
        <div class="game-ui-item">
            <div class="icon">ğŸ†</div>
            <span id="level">1</span>
        </div>
        <div class="game-ui-item">
            <div class="icon">ğŸ”‘</div>
            <span id="keys">0</span>
        </div>
    </div>
    
    <!-- æ¸¸æˆæ§åˆ¶æŒ‰é’® -->
    <div class="game-controls">
        <button class="game-btn" id="pauseBtn">Pause</button>
        <button class="game-btn" id="helpBtn">Help</button>
    </div>
    
    <!-- æ¸¸æˆç»“æŸç•Œé¢ -->
    <div class="game-over" id="game-over">
        <h2>Game Over</h2>
        <p>You completed <span id="completed-levels">0</span> levels</p>
        <p>Total time: <span id="total-time">00:00</span></p>
        <button class="game-over-btn" id="restart-btn">Restart</button>
    </div>

    <script>
        // æ¸¸æˆåŠ è½½
        window.addEventListener('DOMContentLoaded', function() {
            const progressBar = document.getElementById('progress-bar');
            const loadingText = document.getElementById('loading-text');
            const loadingScreen = document.getElementById('loading-screen');
            
            // ç¡®ä¿æ¸¸æˆèƒ½å¤Ÿæ­£å¸¸åˆå§‹åŒ–ï¼Œå³ä½¿åœ¨æŸäº›æµè§ˆå™¨ä¸­å‡ºç°åŠ è½½é—®é¢˜
            try {
                let progress = 0;
                const interval = setInterval(function() {
                    progress += Math.random() * 10;
                    if (progress >= 100) {
                        progress = 100;
                        clearInterval(interval);
                        
                        // æ˜¾ç¤ºæ¸¸æˆï¼Œéšè—åŠ è½½å±å¹•
                        setTimeout(function() {
                            loadingScreen.style.display = 'none';
                            try {
                                initGame();
                            } catch (e) {
                                console.error('æ¸¸æˆåˆå§‹åŒ–å¤±è´¥:', e);
                                // å¦‚æœæ¸¸æˆåˆå§‹åŒ–å¤±è´¥ï¼Œæä¾›é‡æ–°åŠ è½½é€‰é¡¹
                                alert('æ¸¸æˆåŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚é”™è¯¯ï¼š' + e.message);
                                location.reload();
                            }
                        }, 500);
                    }
                    
                    progressBar.style.width = progress + '%';
                    loadingText.textContent = Math.floor(progress) + '%';
                }, 200);
                
                // æ·»åŠ ä¸€ä¸ªå®‰å…¨ä¿éšœæœºåˆ¶ï¼Œé˜²æ­¢é•¿æ—¶é—´åœç•™åœ¨åŠ è½½é¡µé¢
                setTimeout(function() {
                    if (loadingScreen.style.display !== 'none') {
                        loadingScreen.style.display = 'none';
                        try {
                            initGame();
                        } catch (e) {
                            console.error('è¶…æ—¶åæ¸¸æˆåˆå§‹åŒ–å¤±è´¥:', e);
                            alert('æ¸¸æˆåŠ è½½è¶…æ—¶ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚');
                            location.reload();
                        }
                    }
                }, 5000);
            } catch (e) {
                console.error('åŠ è½½è„šæœ¬å¼‚å¸¸:', e);
                loadingScreen.style.display = 'none';
                alert('æ¸¸æˆåŠ è½½å‡ºç°é—®é¢˜ï¼Œè¯·åˆ·æ–°é¡µé¢ã€‚');
            }
        });

        // æ¸¸æˆåˆå§‹åŒ–å’Œä¸»é€»è¾‘
        function initGame() {
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            
            // æ¸¸æˆå¸¸é‡
            const CELL_SIZE = 40;
            const ROWS = 15;
            const COLS = 20;
            
            // è°ƒæ•´Canvaså¤§å°
            canvas.width = COLS * CELL_SIZE;
            canvas.height = ROWS * CELL_SIZE;
            
            // è‡ªé€‚åº”å±å¹•
            function resizeCanvas() {
                const container = document.getElementById('game-container');
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                
                const scaleX = containerWidth / canvas.width;
                const scaleY = containerHeight / canvas.height;
                const scale = Math.min(scaleX, scaleY) * 0.95;
                
                canvas.style.width = (canvas.width * scale) + 'px';
                canvas.style.height = (canvas.height * scale) + 'px';
            }
            
            // è°ƒæ•´ç”»å¸ƒå¤§å°
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // æ¸¸æˆçŠ¶æ€
            const gameState = {
                player: { row: 1, col: 1, keys: 0 },
                level: 1,
                maze: [],
                timeStart: Date.now(),
                timePaused: 0,
                isPaused: false,
                isGameOver: false,
                completedLevels: 0
            };
            
            // è¿·å®«æ–¹å—ç±»å‹
            const CELL_TYPES = {
                WALL: 0,
                PATH: 1,
                START: 2,
                END: 3,
                KEY: 4,
                DOOR: 5,
                TRAP: 6
            };
            
            // æ–¹å‘é”®æ§åˆ¶
            const keys = {
                ArrowUp: false,
                ArrowDown: false,
                ArrowLeft: false,
                ArrowRight: false,
                w: false,
                a: false,
                s: false,
                d: false
            };
            
            // åˆ›å»ºè¿·å®« - ä½¿ç”¨é€’å½’å›æº¯ç®—æ³•
            function generateMaze() {
                // åˆå§‹åŒ–å…¨éƒ¨ä¸ºå¢™
                const maze = Array(ROWS).fill().map(() => Array(COLS).fill(CELL_TYPES.WALL));
                
                // å®šä¹‰èµ·ç‚¹
                const startRow = 1;
                const startCol = 1;
                maze[startRow][startCol] = CELL_TYPES.START;
                
                // é€’å½’åˆ›å»ºè·¯å¾„
                function carve(row, col) {
                    const directions = [
                        [0, 2],  // å³
                        [2, 0],  // ä¸‹
                        [0, -2], // å·¦
                        [-2, 0]  // ä¸Š
                    ];
                    
                    // éšæœºæ’åºæ–¹å‘
                    for (let i = directions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [directions[i], directions[j]] = [directions[j], directions[i]];
                    }
                    
                    // å°è¯•æ¯ä¸ªæ–¹å‘
                    for (const [dr, dc] of directions) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        
                        // æ£€æŸ¥æ˜¯å¦åœ¨è¾¹ç•Œå†…
                        if (newRow > 0 && newRow < ROWS - 1 && newCol > 0 && newCol < COLS - 1) {
                            // å¦‚æœç›®æ ‡å•å…ƒæ ¼ä¸ºå¢™
                            if (maze[newRow][newCol] === CELL_TYPES.WALL) {
                                // æŠŠä¸­é—´çš„å•å…ƒæ ¼è®¾ä¸ºè·¯å¾„
                                maze[row + dr/2][col + dc/2] = CELL_TYPES.PATH;
                                // æŠŠç›®æ ‡å•å…ƒæ ¼è®¾ä¸ºè·¯å¾„
                                maze[newRow][newCol] = CELL_TYPES.PATH;
                                // ç»§ç»­ä»ç›®æ ‡å•å…ƒæ ¼é€’å½’
                                carve(newRow, newCol);
                            }
                        }
                    }
                }
                
                // ä»èµ·ç‚¹å¼€å§‹ç”Ÿæˆè¿·å®«
                carve(startRow, startCol);
                
                // æ”¾ç½®ç»ˆç‚¹
                let endPlaced = false;
                while (!endPlaced) {
                    const endRow = ROWS - 2;
                    const endCol = COLS - 2;
                    
                    if (maze[endRow][endCol] === CELL_TYPES.PATH) {
                        maze[endRow][endCol] = CELL_TYPES.END;
                        endPlaced = true;
                    }
                }
                
                // æ”¾ç½®é’¥åŒ™å’Œé—¨ (æ ¹æ®çº§åˆ«å¢åŠ éš¾åº¦)
                const keyCount = Math.min(3, gameState.level);
                let keysPlaced = 0;
                
                while (keysPlaced < keyCount) {
                    const row = Math.floor(Math.random() * (ROWS - 2)) + 1;
                    const col = Math.floor(Math.random() * (COLS - 2)) + 1;
                    
                    if (maze[row][col] === CELL_TYPES.PATH) {
                        maze[row][col] = CELL_TYPES.KEY;
                        keysPlaced++;
                    }
                }
                
                // æ”¾ç½®é—¨
                let doorsPlaced = 0;
                while (doorsPlaced < keyCount) {
                    const row = Math.floor(Math.random() * (ROWS - 2)) + 1;
                    const col = Math.floor(Math.random() * (COLS - 2)) + 1;
                    
                    // é—¨ä¸åº”è¯¥å®Œå…¨å µæ­»é€šé“ï¼Œéœ€è¦ç¡®ä¿ç©å®¶æœ‰è·¯å¯èµ°
                    if (maze[row][col] === CELL_TYPES.PATH) {
                        maze[row][col] = CELL_TYPES.DOOR;
                        doorsPlaced++;
                    }
                }
                
                // æ”¾ç½®é™·é˜± (æ ¹æ®çº§åˆ«å¢åŠ éš¾åº¦)
                const trapCount = gameState.level;
                let trapsPlaced = 0;
                
                while (trapsPlaced < trapCount) {
                    const row = Math.floor(Math.random() * (ROWS - 2)) + 1;
                    const col = Math.floor(Math.random() * (COLS - 2)) + 1;
                    
                    // é™·é˜±ä¸åº”è¯¥æ”¾åœ¨å…³é”®è·¯å¾„ä¸Š
                    if (maze[row][col] === CELL_TYPES.PATH && 
                        !(row === startRow && col === startCol) && 
                        !(row === ROWS - 2 && col === COLS - 2)) {
                        maze[row][col] = CELL_TYPES.TRAP;
                        trapsPlaced++;
                    }
                }
                
                return maze;
            }
            
            // åˆå§‹åŒ–æ¸¸æˆ
            function initLevel() {
                gameState.maze = generateMaze();
                gameState.player = { row: 1, col: 1, keys: 0 };
                updateUI();
            }
            
            // ç»˜åˆ¶è¿·å®«
            function drawMaze() {
                for (let row = 0; row < ROWS; row++) {
                    for (let col = 0; col < COLS; col++) {
                        const cellType = gameState.maze[row][col];
                        
                        // è®¾ç½®å•å…ƒæ ¼é¢œè‰²
                        switch (cellType) {
                            case CELL_TYPES.WALL:
                                ctx.fillStyle = '#555555';
                                break;
                            case CELL_TYPES.PATH:
                                ctx.fillStyle = '#FFFFFF';
                                break;
                            case CELL_TYPES.START:
                                ctx.fillStyle = '#00FF00';
                                break;
                            case CELL_TYPES.END:
                                ctx.fillStyle = '#FF0000';
                                break;
                            case CELL_TYPES.KEY:
                                ctx.fillStyle = '#FFFF00';
                                break;
                            case CELL_TYPES.DOOR:
                                ctx.fillStyle = '#8B4513';
                                break;
                            case CELL_TYPES.TRAP:
                                ctx.fillStyle = '#FF00FF';
                                break;
                        }
                        
                        // ç»˜åˆ¶å•å…ƒæ ¼
                        ctx.fillRect(col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        
                        // æ·»åŠ è¾¹æ¡†
                        ctx.strokeStyle = '#AAAAAA';
                        ctx.strokeRect(col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        
                        // ç»˜åˆ¶ç‰¹æ®Šå•å…ƒæ ¼çš„å›¾æ ‡
                        if (cellType === CELL_TYPES.KEY) {
                            ctx.fillStyle = '#000000';
                            ctx.font = '20px Arial';
                            ctx.fillText('ğŸ”‘', col * CELL_SIZE + 10, row * CELL_SIZE + 25);
                        } else if (cellType === CELL_TYPES.DOOR) {
                            ctx.fillStyle = '#000000';
                            ctx.font = '20px Arial';
                            ctx.fillText('ğŸšª', col * CELL_SIZE + 10, row * CELL_SIZE + 25);
                        } else if (cellType === CELL_TYPES.TRAP) {
                            ctx.fillStyle = '#000000';
                            ctx.font = '20px Arial';
                            ctx.fillText('ğŸ’€', col * CELL_SIZE + 10, row * CELL_SIZE + 25);
                        } else if (cellType === CELL_TYPES.END) {
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = '20px Arial';
                            ctx.fillText('ğŸ', col * CELL_SIZE + 10, row * CELL_SIZE + 25);
                        }
                    }
                }
            }
            
            // ç»˜åˆ¶ç©å®¶
            function drawPlayer() {
                const x = gameState.player.col * CELL_SIZE;
                const y = gameState.player.row * CELL_SIZE;
                
                // ç»˜åˆ¶ç©å®¶åœ†å½¢
                ctx.fillStyle = '#0000FF';
                ctx.beginPath();
                ctx.arc(x + CELL_SIZE / 2, y + CELL_SIZE / 2, CELL_SIZE / 3, 0, Math.PI * 2);
                ctx.fill();
                
                // ç»˜åˆ¶ç©å®¶çœ¼ç›
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(x + CELL_SIZE / 2 - 5, y + CELL_SIZE / 2 - 5, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(x + CELL_SIZE / 2 + 5, y + CELL_SIZE / 2 - 5, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // æ›´æ–°UIä¿¡æ¯
            function updateUI() {
                document.getElementById('level').textContent = gameState.level;
                document.getElementById('keys').textContent = gameState.player.keys;
                
                // æ›´æ–°æ—¶é—´
                const currentTime = gameState.isPaused ? 
                    gameState.timePaused : 
                    Date.now() - gameState.timeStart;
                const seconds = Math.floor(currentTime / 1000) % 60;
                const minutes = Math.floor(currentTime / 60000);
                
                document.getElementById('time').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            // ç§»åŠ¨ç©å®¶
            function movePlayer(dRow, dCol) {
                if (gameState.isPaused || gameState.isGameOver) return;
                
                const newRow = gameState.player.row + dRow;
                const newCol = gameState.player.col + dCol;
                
                // æ£€æŸ¥æ˜¯å¦è¶…å‡ºè¾¹ç•Œ
                if (newRow < 0 || newRow >= ROWS || newCol < 0 || newCol >= COLS) {
                    return;
                }
                
                const newCell = gameState.maze[newRow][newCol];
                
                // æ£€æŸ¥ç§»åŠ¨ç›®çš„åœ°
                switch (newCell) {
                    case CELL_TYPES.WALL:
                        // ä¸èƒ½ç©¿å¢™
                        return;
                        
                    case CELL_TYPES.PATH:
                    case CELL_TYPES.START:
                        // å¯ä»¥è‡ªç”±ç§»åŠ¨
                        gameState.player.row = newRow;
                        gameState.player.col = newCol;
                        break;
                        
                    case CELL_TYPES.KEY:
                        // æ”¶é›†é’¥åŒ™
                        gameState.player.keys++;
                        gameState.maze[newRow][newCol] = CELL_TYPES.PATH;
                        gameState.player.row = newRow;
                        gameState.player.col = newCol;
                        break;
                        
                    case CELL_TYPES.DOOR:
                        // éœ€è¦é’¥åŒ™æ‰èƒ½é€šè¿‡é—¨
                        if (gameState.player.keys > 0) {
                            gameState.player.keys--;
                            gameState.maze[newRow][newCol] = CELL_TYPES.PATH;
                            gameState.player.row = newRow;
                            gameState.player.col = newCol;
                        }
                        break;
                        
                    case CELL_TYPES.TRAP:
                        // è¸©åˆ°é™·é˜±ï¼Œæ¸¸æˆç»“æŸ
                        gameOver();
                        return;
                        
                    case CELL_TYPES.END:
                        // åˆ°è¾¾ç»ˆç‚¹ï¼Œè¿›å…¥ä¸‹ä¸€å…³
                        nextLevel();
                        return;
                }
                
                updateUI();
            }
            
            // è¿›å…¥ä¸‹ä¸€å…³
            function nextLevel() {
                gameState.level++;
                gameState.completedLevels++;
                initLevel();
            }
            
            // æ¸¸æˆç»“æŸ
            function gameOver() {
                gameState.isGameOver = true;
                
                // æ˜¾ç¤ºæ¸¸æˆç»“æŸç•Œé¢
                document.getElementById('game-over').style.display = 'flex';
                document.getElementById('completed-levels').textContent = gameState.completedLevels;
                
                // è®¡ç®—æ€»ç”¨æ—¶
                const totalTime = Date.now() - gameState.timeStart;
                const seconds = Math.floor(totalTime / 1000) % 60;
                const minutes = Math.floor(totalTime / 60000);
                
                document.getElementById('total-time').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            // é‡æ–°å¼€å§‹æ¸¸æˆ
            function restartGame() {
                gameState.level = 1;
                gameState.isGameOver = false;
                gameState.isPaused = false;
                gameState.timeStart = Date.now();
                gameState.timePaused = 0;
                gameState.completedLevels = 0;
                
                document.getElementById('game-over').style.display = 'none';
                document.getElementById('pauseBtn').textContent = 'Pause';
                
                initLevel();
            }
            
            // å¤„ç†æŒ‰é”®æŒ‰ä¸‹
            function handleKeyDown(e) {
                if (gameState.isGameOver) return;
                
                if (e.key in keys) {
                    keys[e.key] = true;
                    e.preventDefault();
                }
                
                // æš‚åœ/ç»§ç»­æ¸¸æˆ
                if (e.key === 'p' || e.key === 'P') {
                    togglePause();
                }
                
                // å¤„ç†æ–¹å‘é”®ç§»åŠ¨
                if (!gameState.isPaused) {
                    switch (e.key) {
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            movePlayer(-1, 0);
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            movePlayer(1, 0);
                            break;
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            movePlayer(0, -1);
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            movePlayer(0, 1);
                            break;
                    }
                }
            }
            
            // å¤„ç†æŒ‰é”®é‡Šæ”¾
            function handleKeyUp(e) {
                if (e.key in keys) {
                    keys[e.key] = false;
                    e.preventDefault();
                }
            }
            
            // åˆ‡æ¢æš‚åœçŠ¶æ€
            function togglePause() {
                if (gameState.isGameOver) return;
                
                gameState.isPaused = !gameState.isPaused;
                
                if (gameState.isPaused) {
                    // Pause timer
                    gameState.timePaused = Date.now() - gameState.timeStart;
                    document.getElementById('pauseBtn').textContent = 'Continue';
                } else {
                    // Resume timer
                    gameState.timeStart = Date.now() - gameState.timePaused;
                    document.getElementById('pauseBtn').textContent = 'Pause';
                }
            }
            
            // Show help information
            function showHelp() {
                alert(`Maze Adventure Game Instructions:
                
1. Use arrow keys or WASD to move your character
2. Collect keys(ğŸ”‘) to open doors(ğŸšª)
3. Avoid traps(ğŸ’€)
4. Reach the exit(ğŸ) to advance to the next level
5. Press P or click the pause button to pause the game`);
            }
            
            // æ¸¸æˆä¸»å¾ªç¯
            function gameLoop() {
                // æ¸…ç©ºç”»å¸ƒ
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // ç»˜åˆ¶è¿·å®«
                drawMaze();
                
                // ç»˜åˆ¶ç©å®¶
                drawPlayer();
                
                // æ›´æ–°UI
                if (!gameState.isPaused && !gameState.isGameOver) {
                    updateUI();
                }
                
                // ç»§ç»­å¾ªç¯
                requestAnimationFrame(gameLoop);
            }
            
            // åˆå§‹åŒ–æ¸¸æˆ
            initLevel();
            
            // å¼€å§‹æ¸¸æˆå¾ªç¯
            gameLoop();
            
            // äº‹ä»¶ç›‘å¬
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            document.getElementById('pauseBtn').addEventListener('click', togglePause);
            document.getElementById('helpBtn').addEventListener('click', showHelp);
            document.getElementById('restart-btn').addEventListener('click', restartGame);
            
            // å“åº”æ¥è‡ªçˆ¶é¡µé¢çš„æ¶ˆæ¯
            window.addEventListener('message', function(event) {
                if (event.data === 'fullscreen') {
                    // å“åº”å…¨å±è¯·æ±‚
                    if (canvas.requestFullscreen) {
                        canvas.requestFullscreen();
                    } else if (canvas.webkitRequestFullscreen) {
                        canvas.webkitRequestFullscreen();
                    } else if (canvas.msRequestFullscreen) {
                        canvas.msRequestFullscreen();
                    }
                } else if (event.data === 'restart') {
                    // å“åº”é‡å¯è¯·æ±‚
                    restartGame();
                }
            });
        }
    </script>
</body>
</html> 